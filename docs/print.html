<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Codebook</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script defer src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                asciimath2jax: {
                    delimiters: [['[{','}]']]
                },
                tex2jax: {
                    inlineMath: [['$', '$']],
                    displayMath: [['$$', '$$']],
                }
            });
        </script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="datastructures/index.html"><strong aria-hidden="true">1.</strong> Data Structures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="datastructures/prefix_sum.html"><strong aria-hidden="true">1.1.</strong> Prefix Sum</a></li><li class="chapter-item "><a href="datastructures/dsu.html"><strong aria-hidden="true">1.2.</strong> Disjoin Set</a></li><li class="chapter-item "><a href="datastructures/bit.html"><strong aria-hidden="true">1.3.</strong> BIT</a></li><li class="chapter-item "><a href="datastructures/mint.html"><strong aria-hidden="true">1.4.</strong> Mint</a></li><li class="chapter-item "><a href="datastructures/segtree.html"><strong aria-hidden="true">1.5.</strong> SegTree</a></li><li class="chapter-item "><a href="datastructures/lazysegtree.html"><strong aria-hidden="true">1.6.</strong> LazySegTree</a></li><li class="chapter-item "><a href="datastructures/sparse_table.html"><strong aria-hidden="true">1.7.</strong> Sparse Table</a></li><li class="chapter-item "><a href="datastructures/treap.html"><strong aria-hidden="true">1.8.</strong> Treap</a></li><li class="chapter-item "><a href="datastructures/matrix.html"><strong aria-hidden="true">1.9.</strong> Matrix</a></li><li class="chapter-item "><a href="datastructures/prefix2d.html"><strong aria-hidden="true">1.10.</strong> Prefix2D</a></li></ol></li><li class="chapter-item "><a href="algorithms/index.html"><strong aria-hidden="true">2.</strong> Algorithms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="algorithms/powmod.html"><strong aria-hidden="true">2.1.</strong> Powmod</a></li><li class="chapter-item "><a href="algorithms/permutation.html"><strong aria-hidden="true">2.2.</strong> Permutation</a></li><li class="chapter-item "><a href="algorithms/polyhash.html"><strong aria-hidden="true">2.3.</strong> PolyHash</a></li><li class="chapter-item "><a href="algorithms/polyhash2.html"><strong aria-hidden="true">2.4.</strong> PolyHash2</a></li><li class="chapter-item "><a href="algorithms/dijkstra.html"><strong aria-hidden="true">2.5.</strong> Dijkstra</a></li><li class="chapter-item "><a href="algorithms/spfa.html"><strong aria-hidden="true">2.6.</strong> SPFA</a></li><li class="chapter-item "><a href="algorithms/topological_sort.html"><strong aria-hidden="true">2.7.</strong> Topological Sort</a></li><li class="chapter-item "><a href="algorithms/tarjan_scc.html"><strong aria-hidden="true">2.8.</strong> Tarjan SCC</a></li><li class="chapter-item "><a href="algorithms/2-sat.html"><strong aria-hidden="true">2.9.</strong> 2-SAT</a></li><li class="chapter-item "><a href="algorithms/ecc.html"><strong aria-hidden="true">2.10.</strong> Diameter, Radius, Eccentricity</a></li><li class="chapter-item "><a href="algorithms/lca.html"><strong aria-hidden="true">2.11.</strong> LCA</a></li><li class="chapter-item "><a href="algorithms/ternary_search.html"><strong aria-hidden="true">2.12.</strong> Ternary Search</a></li><li class="chapter-item "><a href="algorithms/combtool.html"><strong aria-hidden="true">2.13.</strong> CombTool</a></li><li class="chapter-item "><a href="algorithms/linear_congruence_crt.html"><strong aria-hidden="true">2.14.</strong> Linear Congruence & CRT</a></li><li class="chapter-item "><a href="algorithms/linear_congruence_crt.html"><strong aria-hidden="true">2.15.</strong> Sieve of Eratosthenes</a></li></ol></li><li class="chapter-item "><a href="techniques/index.html"><strong aria-hidden="true">3.</strong> Techniques</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="techniques/ceil_floor_div.html"><strong aria-hidden="true">3.1.</strong> Ceil/Floor Division</a></li><li class="chapter-item "><a href="techniques/square_number.html"><strong aria-hidden="true">3.2.</strong> Square Number</a></li><li class="chapter-item "><a href="techniques/multiples_in_range.html"><strong aria-hidden="true">3.3.</strong> Multiples in Range</a></li><li class="chapter-item "><a href="techniques/2_sets.html"><strong aria-hidden="true">3.4.</strong> 2 Sets</a></li><li class="chapter-item "><a href="techniques/longest_common_prefix.html"><strong aria-hidden="true">3.5.</strong> Longest Common Prefix</a></li><li class="chapter-item "><a href="techniques/coordinate_compression.html"><strong aria-hidden="true">3.6.</strong> Coordinate Compression</a></li><li class="chapter-item "><a href="techniques/functional_graph.html"><strong aria-hidden="true">3.7.</strong> Functional Graph</a></li><li class="chapter-item "><a href="techniques/max_match_subseq.html"><strong aria-hidden="true">3.8.</strong> Maximum Match Subsequence</a></li><li class="chapter-item "><a href="techniques/merged.html"><strong aria-hidden="true">3.9.</strong> Merge 2 Sorted Array</a></li></ol></li><li class="chapter-item "><a href="miscellaneous/index.html"><strong aria-hidden="true">4.</strong> Miscellaneous</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="miscellaneous/rust_basic.html"><strong aria-hidden="true">4.1.</strong> Rust Basic</a></li><li class="chapter-item "><a href="miscellaneous/cartesian_product.html"><strong aria-hidden="true">4.2.</strong> Cartesian Product</a></li><li class="chapter-item "><a href="miscellaneous/ordered_float.html"><strong aria-hidden="true">4.3.</strong> Ordered Float</a></li><li class="chapter-item "><a href="miscellaneous/default_hashing.html"><strong aria-hidden="true">4.4.</strong> Default Hasing</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Codebook</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/amoshyc/cp-codebook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefix-sum"><a class="header" href="#prefix-sum">Prefix Sum</a></h1>
<pre><code class="language-rust">fn build&lt;T&gt;(arr: &amp;[T]) -&gt; Vec&lt;T&gt;
where
    T: Copy + std::ops::Add&lt;Output = T&gt;,
{
    let mut pref = vec![];
    pref.push(arr[0]);
    for i in 1..arr.len() {
        pref.push(pref[i - 1] + arr[i]);
    }
    pref
}

// i..j
fn query&lt;T&gt;(pref: &amp;[T], i: usize, j: usize) -&gt; T
where
    T: Default + Copy + std::ops::Sub&lt;Output = T&gt;,
{
    if i == j {
        return T::default();
    }
    let mut res = pref[j - 1];
    if i &gt; 0 {
        res = res - pref[i - 1];
    }
    res
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dsu"><a class="header" href="#dsu">DSU</a></h1>
<pre><code class="language-rust">struct DSU {
    par: Vec&lt;usize&gt;,
    siz: Vec&lt;usize&gt;,
}

impl DSU {
    fn new(n: usize) -&gt; Self {
        Self {
            par: (0..n).collect(),
            siz: vec![1; n],
        }
    }

    fn root(&amp;mut self, u: usize) -&gt; usize {
        if self.par[u] == u {
            u
        } else {
            self.par[u] = self.root(self.par[u]);
            self.par[u]
        }
    }

    fn unite(&amp;mut self, mut u: usize, mut v: usize) {
        u = self.root(u);
        v = self.root(v);
        if u == v {
            return;
        }
        if self.siz[u] &gt; self.siz[v] {
            self.par[v] = u;
            self.siz[u] += self.siz[v];
        } else {
            self.par[u] = v;
            self.siz[v] += self.siz[u];
        }
    }

    fn same(&amp;mut self, u: usize, v: usize) -&gt; bool {
        self.root(u) == self.root(v)
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit"><a class="header" href="#bit">BIT</a></h1>
<pre><code class="language-rust">struct BIT&lt;T&gt; {
    dat: Vec&lt;T&gt;,
}

impl&lt;T: Clone + Default + std::ops::AddAssign + std::ops::Sub&lt;Output = T&gt;&gt; BIT&lt;T&gt; {
    fn new(n: usize) -&gt; Self {
        Self {
            dat: vec![T::default(); n + 1],
        }
    }

    // 0-based
    fn add(&amp;mut self, mut i: usize, x: T) {
        i += 1; // convert to 1-based
        while i &lt; self.dat.len() {
            self.dat[i] += x.clone();
            i += i &amp; (!i + 1); // i &amp; (-i)
        }
    }

    // 0..=i, 0-based
    fn pref(&amp;self, mut i: usize) -&gt; T {
        let mut res = T::default();
        i += 1; // convert to 1-based
        while i &gt; 0 {
            res += self.dat[i].clone();
            i -= i &amp; (!i + 1);
        }
        res
    }

    // l..i, 0-based
    fn sum(&amp;self, mut l: usize, mut r: usize) -&gt; T {
        if r == 0 {
            T::default()
        } else if l &gt;= 1 {
            self.pref(r - 1) - self.pref(l - 1)
        } else {
            self.pref(r - 1)
        }
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc231/submissions/42564667">https://atcoder.jp/contests/abc231/submissions/42564667</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mint"><a class="header" href="#mint">Mint</a></h1>
<pre><code class="language-rust">#[derive(Debug, Copy, Clone)]
struct Mint(u64);

impl Mint {
    const MOD: u64 = 998_244_353;
    fn inv(&amp;self) -&gt; Mint {
        let mut a = self.0 as i64;
        let mut b = Mint::MOD as i64;
        let mut p = 1 as i64;
        let mut q = 0 as i64;
        while b != 0 {
            let (c, r) = (a / b, a % b);
            a = b;
            b = r;
            let tmp = p - c * q;
            p = q;
            q = tmp;
        }
        Mint(p.rem_euclid(Mint::MOD as i64) as u64)
    }
    fn pow(&amp;self, mut b: u64) -&gt; Mint {
        let mut base = *self;
        let mut res = Mint(1);
        while b != 0 {
            if b &amp; 1 == 1 {
                res = res * base;
            }
            base = base * base;
            b &gt;&gt;= 1;
        }
        res
    }
}
impl Default for Mint {
    fn default() -&gt; Self {
        Self(0)
    }
}
impl std::ops::Add for Mint {
    type Output = Mint;
    fn add(self, rhs: Mint) -&gt; Mint {
        Mint((self.0 + rhs.0) % Mint::MOD)
    }
}
impl std::ops::Sub for Mint {
    type Output = Mint;
    fn sub(self, rhs: Mint) -&gt; Mint {
        Mint((self.0 + Mint::MOD - rhs.0) % Mint::MOD)
    }
}
impl std::ops::Mul for Mint {
    type Output = Mint;
    fn mul(self, rhs: Mint) -&gt; Mint {
        Mint(self.0 * rhs.0 % Mint::MOD)
    }
}
impl std::ops::Div for Mint {
    type Output = Mint;
    fn div(self, rhs: Mint) -&gt; Mint {
        self * rhs.inv()
    }
}
impl std::ops::AddAssign for Mint {
    fn add_assign(&amp;mut self, rhs: Self) {
        *self = Mint((self.0 + rhs.0) % Mint::MOD);
    }
}
impl std::ops::SubAssign for Mint {
    fn sub_assign(&amp;mut self, rhs: Self) {
        *self = Mint((self.0 + Mint::MOD - rhs.0) % Mint::MOD);
    }
}
impl std::ops::MulAssign for Mint {
    fn mul_assign(&amp;mut self, rhs: Self) {
        *self = Mint((self.0 * rhs.0) % Mint::MOD);
    }
}
impl std::ops::DivAssign for Mint {
    fn div_assign(&amp;mut self, rhs: Self) {
        *self = *self * rhs.inv();
    }
}
impl std::fmt::Display for Mint {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, "{}", self.0)
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc265/submissions/37053848">https://atcoder.jp/contests/abc265/submissions/37053848</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="segtree"><a class="header" href="#segtree">SegTree</a></h1>
<pre><code class="language-rust">struct Node;
impl SegTrait for Node {
    type S = i32;
    fn default() -&gt; Self::S {
        10i32.pow(9)
    }
    fn op(a: Self::S, b: Self::S) -&gt; Self::S {
        a.min(b)
    }
}

trait SegTrait {
    type S: Clone;
    fn default() -&gt; Self::S;
    fn op(a: Self::S, b: Self::S) -&gt; Self::S;
}

struct SegTree&lt;T: SegTrait&gt; {
    nn: usize,
    data: Vec&lt;T::S&gt;,
}

impl&lt;T: SegTrait&gt; SegTree&lt;T&gt; {
    fn new(n: usize) -&gt; Self {
        let nn = n.next_power_of_two();
        let data = vec![T::default(); 2 * nn];
        Self { nn, data }
    }

    fn from_vec(arr: &amp;Vec&lt;T::S&gt;) -&gt; Self {
        let nn = arr.len().next_power_of_two();
        let mut data = vec![T::default(); 2 * nn];
        let s = nn - 1;
        let t = s + arr.len();
        data[s..t].clone_from_slice(arr);
        for u in (0..s).rev() {
            data[u] = T::op(data[2 * u + 1].clone(), data[2 * u + 2].clone());
        }
        Self { nn, data }
    }

    fn get(&amp;mut self, a: usize, b: usize, u: usize, l: usize, r: usize) -&gt; T::S {
        // l..r has no intersection with a..b
        if l &gt;= b || r &lt;= a {
            return T::default();
        }
        // l..r is inside a..b
        if l &gt;= a &amp;&amp; r &lt;= b {
            return self.data[u].clone();
        }
        // partially intersect
        let m = (l + r) / 2;
        T::op(
            self.get(a, b, 2 * u + 1, l, m),
            self.get(a, b, 2 * u + 2, m, r),
        )
    }

    fn set(&amp;mut self, i: usize, x: T::S, u: usize, l: usize, r: usize) {
        // l..r has no intersection with i..i+1
        if l &gt;= i + 1 || r &lt;= i {
            return;
        }
        // l..r is inside i..i+1
        if l &gt;= i &amp;&amp; r &lt;= i + 1 {
            self.data[u] = x;
            return;
        }
        // partially intersect
        let (m, lch, rch) = ((l + r) / 2, 2 * u + 1, 2 * u + 2);
        self.set(i, x.clone(), lch, l, m);
        self.set(i, x.clone(), rch, m, r);
        self.data[u] = T::op(self.data[lch].clone(), self.data[rch].clone());
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc283/submissions/46191119">https://atcoder.jp/contests/abc283/submissions/46191119</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lazysegtree"><a class="header" href="#lazysegtree">LazySegTree</a></h1>
<pre><code class="language-rust noplayground">struct Node;
impl SegTrait for Node {
    type S = u64;
    type F = (u64, u64);
    fn default_data() -&gt; Self::S {
        0
    }
    fn default_lazy() -&gt; Self::F {
        (1, 0)
    }
    fn op(a: Self::S, b: Self::S) -&gt; Self::S {
        (a + b) % M
    }
    fn apply_lazy(lazy: Self::F, data: Self::S, l: usize, r: usize) -&gt; Self::S {
        let (b, c) = lazy;
        let mut res = b * data % M;
        res += c * ((r - l) as u64) % M;
        res % M
    }
    fn merge_lazy(parent: Self::F, child: Self::F) -&gt; Self::F {
        let (b1, c1) = parent;
        let (b2, c2) = child;
        let b = b1 * b2 % M;
        let c = (b1 * c2 % M + c1) % M;
        (b, c)
    }
}

trait SegTrait {
    type S: Clone + PartialEq + std::fmt::Debug;
    type F: Clone + PartialEq + std::fmt::Debug;
    fn default_data() -&gt; Self::S;
    fn default_lazy() -&gt; Self::F;
    fn op(a: Self::S, b: Self::S) -&gt; Self::S;
    fn apply_lazy(lazy: Self::F, data: Self::S, l: usize, r: usize) -&gt; Self::S;
    fn merge_lazy(parent: Self::F, child: Self::F) -&gt; Self::F;
}

struct SegTree&lt;T: SegTrait&gt; {
    nn: usize,
    data: Vec&lt;T::S&gt;,
    lazy: Vec&lt;T::F&gt;,
}

impl&lt;T: SegTrait&gt; SegTree&lt;T&gt; {
    fn new(n: usize) -&gt; Self {
        let nn = n.next_power_of_two();
        let data = vec![T::default_data(); 2 * nn];
        let lazy = vec![T::default_lazy(); 2 * nn];
        Self { nn, data, lazy }
    }

    fn from_vec(arr: &amp;Vec&lt;T::S&gt;) -&gt; Self {
        let nn = arr.len().next_power_of_two();
        let mut data = vec![T::default_data(); 2 * nn];
        let lazy = vec![T::default_lazy(); 2 * nn];
        let s = nn - 1;
        let t = s + arr.len();
        data[s..t].clone_from_slice(arr);
        for u in (0..s).rev() {
            data[u] = T::op(data[2 * u + 1].clone(), data[2 * u + 2].clone());
        }
        Self { nn, data, lazy }
    }

    fn push(&amp;mut self, u: usize, l: usize, r: usize) {
        if self.lazy[u] != T::default_lazy() {
            let (m, lch, rch) = ((l + r) / 2, 2 * u + 1, 2 * u + 2);
            self.data[lch] = T::apply_lazy(self.lazy[u].clone(), self.data[lch].clone(), l, m);
            self.data[rch] = T::apply_lazy(self.lazy[u].clone(), self.data[rch].clone(), m, r);
            self.lazy[lch] = T::merge_lazy(self.lazy[u].clone(), self.lazy[lch].clone());
            self.lazy[rch] = T::merge_lazy(self.lazy[u].clone(), self.lazy[rch].clone());
            self.lazy[u] = T::default_lazy();
        }
    }

    fn query(&amp;mut self, a: usize, b: usize, u: usize, l: usize, r: usize) -&gt; T::S {
        // l..r has no intersection with a..b
        if l &gt;= b || r &lt;= a {
            return T::default_data();
        }
        // l..r is inside a..b
        if l &gt;= a &amp;&amp; r &lt;= b {
            return self.data[u].clone();
        }
        // partially intersect
        let (m, lch, rch) = ((l + r) / 2, 2 * u + 1, 2 * u + 2);
        self.push(u, l, r);
        T::op(self.query(a, b, lch, l, m), self.query(a, b, rch, m, r))
    }

    fn modify(&amp;mut self, a: usize, b: usize, x: T::F, u: usize, l: usize, r: usize) {
        // l..r has no intersection with a..b
        if l &gt;= b || r &lt;= a {
            return;
        }
        // l..r is inside a..b
        if l &gt;= a &amp;&amp; r &lt;= b {
            self.data[u] = T::apply_lazy(x.clone(), self.data[u].clone(), l, r);
            self.lazy[u] = T::merge_lazy(x.clone(), self.lazy[u].clone());
            return;
        }
        // partially intersect
        let (m, lch, rch) = ((l + r) / 2, 2 * u + 1, 2 * u + 2);
        self.push(u, l, r);
        self.modify(a, b, x.clone(), lch, l, m);
        self.modify(a, b, x.clone(), rch, m, r);
        self.data[u] = T::op(self.data[lch].clone(), self.data[rch].clone());
    }

    fn find_first_of&lt;P: Copy + Fn(T::S) -&gt; bool&gt;(
        &amp;mut self,
        f: P,
        a: usize,
        b: usize,
        u: usize,
        l: usize,
        r: usize,
    ) -&gt; Option&lt;usize&gt; {
        if l &gt;= b || r &lt;= a || f(self.data[u].clone()) {
            return None;
        }
        if r - l == 1 {
            return Some(l);
        }
        let (m, lch, rch) = ((l + r) / 2, 2 * u + 1, 2 * u + 2);
        self.push(u, l, r);
        if let Some(idx) = self.find_first_of(f, a, b, lch, l, m) {
            return Some(idx);
        }
        if let Some(idx) = self.find_first_of(f, a, b, rch, m, r) {
            return Some(idx);
        }
        None
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/practice2/submissions/49674983">https://atcoder.jp/contests/practice2/submissions/49674983</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse-table"><a class="header" href="#sparse-table">Sparse Table</a></h1>
<pre><code class="language-rust">struct SparseTable&lt;T&gt; {
    dp: Vec&lt;Vec&lt;T&gt;&gt;,
    op: fn(T, T) -&gt; T,
}

impl&lt;T: Copy&gt; SparseTable&lt;T&gt; {
    fn new(arr: &amp;Vec&lt;T&gt;, op: fn(T, T) -&gt; T) -&gt; Self {
        let nn = (arr.len() as f64).log2() as usize + 1;
        let mut dp = vec![arr.clone(); nn];
        for i in 1..nn {
            for u in 0..=(arr.len() - (1 &lt;&lt; i)) {
                dp[i][u] = (op)(dp[i - 1][u], dp[i - 1][u + (1 &lt;&lt; (i - 1))]);
            }
        }
        Self { dp, op }
    }

    // a..b
    fn query(&amp;self, a: usize, b: usize) -&gt; T {
        assert!(a != b);
        let k = ((b - a) as f64).log2() as usize;
        (self.op)(self.dp[k][a], self.dp[k][b - (1 &lt;&lt; k)])
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc254/submissions/41799326">https://atcoder.jp/contests/abc254/submissions/41799326</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="treap"><a class="header" href="#treap">Treap</a></h1>
<pre><code class="language-rust">#[derive(Debug)]
struct Treap&lt;T&gt; {
    root: Option&lt;usize&gt;,
    lch: Vec&lt;Option&lt;usize&gt;&gt;,
    rch: Vec&lt;Option&lt;usize&gt;&gt;,
    siz: Vec&lt;usize&gt;,
    key: Vec&lt;T&gt;,
    rnd: Vec&lt;u32&gt;,
    seed: u32,
}

impl&lt;T: std::cmp::PartialOrd + std::fmt::Debug + Clone&gt; Treap&lt;T&gt; {
    fn new() -&gt; Self {
        Self {
            root: None,
            lch: vec![],
            rch: vec![],
            siz: vec![],
            key: vec![],
            rnd: vec![],
            seed: 123,
        }
    }

    fn new_node(&amp;mut self, k: T) -&gt; usize {
        let mut rnd = self.seed;
        rnd ^= rnd &lt;&lt; 13;
        rnd ^= rnd &gt;&gt; 17;
        rnd ^= rnd &lt;&lt; 5;
        self.seed = rnd;

        let id = self.key.len();
        self.lch.push(None);
        self.rch.push(None);
        self.siz.push(1);
        self.key.push(k);
        self.rnd.push(rnd);
        id
    }

    fn size(&amp;self, t: Option&lt;usize&gt;) -&gt; usize {
        if let Some(t) = t {
            self.siz[t]
        } else {
            0
        }
    }

    fn pull(&amp;mut self, t: usize) {
        self.siz[t] = 1 + self.size(self.lch[t]) + self.size(self.rch[t]);
    }

    fn split_by_key(&amp;mut self, t: Option&lt;usize&gt;, k: T) -&gt; (Option&lt;usize&gt;, Option&lt;usize&gt;) {
        if let Some(t) = t {
            if k &lt;= self.key[t] {
                let (a, b) = self.split_by_key(self.lch[t], k);
                self.lch[t] = b;
                self.pull(t);
                (a, Some(t))
            } else {
                let (a, b) = self.split_by_key(self.rch[t], k);
                self.rch[t] = a;
                self.pull(t);
                (Some(t), b)
            }
        } else {
            (None, None)
        }
    }

    fn merge(&amp;mut self, a: Option&lt;usize&gt;, b: Option&lt;usize&gt;) -&gt; Option&lt;usize&gt; {
        if let (Some(a), Some(b)) = (a, b) {
            if self.rnd[a] &gt; self.rnd[b] {
                self.rch[a] = self.merge(self.rch[a], Some(b));
                self.pull(a);
                Some(a)
            } else {
                self.lch[b] = self.merge(Some(a), self.lch[b]);
                self.pull(b);
                Some(b)
            }
        } else {
            a.or(b)
        }
    }

    fn insert(&amp;mut self, t: Option&lt;usize&gt;, k: T) -&gt; Option&lt;usize&gt; {
        let node = self.new_node(k.clone());
        let (t1, t2) = self.split_by_key(t, k);
        let res = self.merge(t1, Some(node));
        let res = self.merge(res, t2);
        res
    }

    fn print(&amp;self, t: Option&lt;usize&gt;, dep: usize) {
        let margin = " ".repeat(dep * 3);
        if let Some(t) = t {
            print!("{}(", margin);
            print!(
                "\n{} k={:?}, r={}, s={}",
                margin, self.key[t], self.rnd[t], self.siz[t]
            );
            print!("\n{} lch=\n", margin);
            self.print(self.lch[t], dep + 1);
            print!("\n{} rch=\n", margin);
            self.print(self.rch[t], dep + 1);
            print!("\n{})", margin);
        } else {
            print!("{}None", margin);
        }
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc231/submissions/43081575">https://atcoder.jp/contests/abc231/submissions/43081575</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="matrix"><a class="header" href="#matrix">Matrix</a></h1>
<pre><code class="language-rust">type Mat = Vec&lt;Vec&lt;u64&gt;&gt;;

fn matmul(a: &amp;Mat, b: &amp;Mat, mls: u64) -&gt; Mat {
    let (n, m) = (a.len(), b[0].len());
    let mut res = vec![vec![0; m]; n];
    for r in 0..n {
        for c in 0..m {
            for k in 0..(b.len()) {
                res[r][c] += a[r][k] * b[k][c];
                res[r][c] %= mls;
            }
        }
    }
    res
}

fn matpow(mat: &amp;Mat, mut exp: u64, m: u64) -&gt; Mat {
    let n = mat.len();
    let mut base = mat.clone();
    let mut ans = vec![vec![0; n]; n];
    for i in 0..n {
        ans[i][i] = 1;
    }
    while exp &gt; 0 {
        if (exp &amp; 1) &gt; 0 {
            ans = matmul(&amp;ans, &amp;base, m);
        }
        base = matmul(&amp;base, &amp;base, m);
        exp &gt;&gt;= 1;
    }
    ans
}

// rotate clockwise
fn r90cw&lt;T: Default + Clone&gt;(arr: &amp;Vec&lt;Vec&lt;T&gt;&gt;) -&gt; Vec&lt;Vec&lt;T&gt;&gt; {
    let (n, m) = (arr.len(), arr[0].len());
    let mut res = vec![vec![T::default(); n]; m];
    for r in 0..n {
        for c in 0..m {
            res[r][c] = arr[c][n - 1 - r].clone();
        }
    }
    res
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc293/submissions/39650552">https://atcoder.jp/contests/abc293/submissions/39650552</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prefix-2d"><a class="header" href="#prefix-2d">Prefix 2D</a></h1>
<pre><code class="language-rust">fn build_2d&lt;T&gt;(arr: &amp;Vec&lt;Vec&lt;T&gt;&gt;) -&gt; Vec&lt;Vec&lt;T&gt;&gt;
where
    T: Default + Copy + std::ops::Add&lt;Output = T&gt; + std::ops::Sub&lt;Output = T&gt;,
{
    assert!(arr.len() &gt;= 1 &amp;&amp; arr[0].len() &gt;= 1);
    let (n, m) = (arr.len(), arr[0].len());
    let mut pref = vec![vec![T::default(); m]; n];
    for r in 0..n {
        for c in 0..m {
            pref[r][c] = arr[r][c];
            if r &gt;= 1 {
                pref[r][c] = pref[r][c] + pref[r - 1][c];
            }
            if c &gt;= 1 {
                pref[r][c] = pref[r][c] + pref[r][c - 1];
            }
            if r &gt;= 1 &amp;&amp; c &gt;= 1 {
                pref[r][c] = pref[r][c] - pref[r - 1][c - 1];
            }
        }
    }
    pref
}

// arr[r1..=r2, c1..=c2]
fn query_2d&lt;T&gt;(pref: &amp;Vec&lt;Vec&lt;T&gt;&gt;, r1: usize, c1: usize, r2: usize, c2: usize) -&gt; T
where
    T: Default + Copy + std::ops::Add&lt;Output = T&gt; + std::ops::Sub&lt;Output = T&gt;,
{
    let mut res = pref[r2][c2];
    if r1 &gt;= 1 {
        res = res - pref[r1 - 1][c2];
    }
    if c1 &gt;= 1 {
        res = res - pref[r2][c1 - 1];
    }
    if r1 &gt;= 1 &amp;&amp; c1 &gt;= 1 {
        res = res + pref[r1 - 1][c1 - 1];
    }
    res
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algorithms"><a class="header" href="#algorithms">Algorithms</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="powmod"><a class="header" href="#powmod">Powmod</a></h1>
<pre><code class="language-rust">fn powmod(a: u64, mut b: u64, m: u64) -&gt; u64 {
    let mut base = a % m;
    let mut res = 1;
    while b != 0 {
        if b &amp; 1 == 1 {
            res = res * base % m;
        }
        base = base * base % m;
        b &gt;&gt;= 1;
    }
    res
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="permutation"><a class="header" href="#permutation">Permutation</a></h2>
<pre><code class="language-rust">loop {
    println!("{:?}", p);
    if next_permutation(&amp;mut p).is_none() {
        break;
    }
}

fn next_permutation&lt;T: Ord&gt;(arr: &amp;mut [T]) -&gt; Option&lt;()&gt; {
    let k = arr.windows(2).rposition(|w| w[0] &lt; w[1])?;
    let j = arr.iter().rposition(|a| a &gt; &amp;arr[k]).unwrap();
    arr.swap(k, j);
    arr[(k + 1)..].reverse();
    Some(())
}

fn prev_permutation&lt;T: Ord&gt;(arr: &amp;mut [T]) -&gt; Option&lt;()&gt; {
    let k = arr.windows(2).rposition(|w| w[0] &gt; w[1])?;
    let j = arr.iter().rposition(|a| a &lt; &amp;arr[k]).unwrap();
    arr.swap(k, j);
    arr[(k + 1)..].reverse();
    Some(())
}

// Modified from https://docs.python.org/3/library/itertools.html#itertools.combinations
fn combinations&lt;T: Copy&gt;(arr: &amp;[T], r: usize) -&gt; impl std::iter::Iterator&lt;Item = Vec&lt;T&gt;&gt; + '_ {
    assert!(r &lt;= arr.len());
    let n = arr.len();
    let mut indices = (0..r).collect::&lt;Vec&lt;usize&gt;&gt;();
    let iter1 = std::iter::once(indices.iter().map(|&amp;i| arr[i]).collect::&lt;Vec&lt;T&gt;&gt;());
    let iter2 = std::iter::from_fn(move || {
        while let Some(i) = (0..r).rposition(|j| indices[j] != j + n - r) {
            indices[i] += 1;
            for j in (i + 1)..r {
                indices[j] = indices[j - 1] + 1
            }
            return Some(indices.iter().map(|&amp;i| arr[i]).collect::&lt;Vec&lt;T&gt;&gt;());
        }
        None
    });
    iter1.chain(iter2)
}</code></pre>
<p>Ref:</p>
<ul>
<li><a href="https://leetcode.com/problems/next-permutation/solution/">next_permutation</a></li>
<li><a href="https://leetcode.cn/problems/iterator-for-combination/solutions/101723/zi-mu-zu-he-die-dai-qi-by-leetcode-solution/">next_combination</a></li>
</ul>
<p><a href="https://atcoder.jp/contests/abc328/submissions/47509695">https://atcoder.jp/contests/abc328/submissions/47509695</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polyhash"><a class="header" href="#polyhash">PolyHash</a></h1>
<pre><code class="language-rust">fn powmod(a: u64, mut b: u64, m: u64) -&gt; u64 {
    let mut base = a % m;
    let mut res = 1;
    while b != 0 {
        if b &amp; 1 == 1 {
            res = res * base % m;
        }
        base = base * base % m;
        b &gt;&gt;= 1;
    }
    res
}

struct PolyHasher {
    prime: u64,
    powr: Vec&lt;u64&gt;,
    pinv: Vec&lt;u64&gt;,
}

impl PolyHasher {
    fn new(n: usize, base: u64, prime: u64) -&gt; PolyHasher {
        let mut powr = vec![1; n];
        let mut pinv = vec![1; n];
        for i in 1..n {
            powr[i] = powr[i - 1] * base % prime;
        }
        pinv[n - 1] = powmod(powr[n - 1], prime - 2, prime);
        for i in (0..(n - 1)).rev() {
            pinv[i] = pinv[i + 1] * base % prime;
        }
        PolyHasher { prime, powr, pinv }
    }

    fn hash(&amp;self, arr: &amp;[u64]) -&gt; Vec&lt;u64&gt; {
        assert!(arr.iter().all(|&amp;x| x != 0));
        let mut h = vec![0; arr.len()];
        h[0] = arr[0] % self.prime;
        for i in 1..arr.len() {
            h[i] = (h[i - 1] + arr[i] * self.powr[i] % self.prime) % self.prime;
        }
        h
    }

    // l..r
    // rev(S[l..r]) = revS[(n - r)..(n - l)]
    fn range(&amp;self, h: &amp;[u64], l: usize, r: usize) -&gt; u64 {
        assert!(l &lt; h.len());
        assert!(r &lt;= h.len());
        if l == r {
            0
        } else if l == 0 {
            h[r - 1]
        } else {
            (self.prime + h[r - 1] - h[l - 1]) % self.prime * self.pinv[l] % self.prime
        }
    }
}</code></pre>
<h2 id="palindromereverse"><a class="header" href="#palindromereverse">Palindrome/Reverse</a></h2>
<pre><code class="language-rust">rev(S[l..r]) = revS[(n - r)..(n - l)]</code></pre>
<h2 id="compare-lexicographically"><a class="header" href="#compare-lexicographically">Compare Lexicographically</a></h2>
<p>To compare 2 strings lexicographically, one can find their longest common prefix
using binary search + hashing and compare the next char.</p>
<h2 id="concatenationrepeat"><a class="header" href="#concatenationrepeat">Concatenation/Repeat</a></h2>
<p>Concat string s and string t can be done in O(1) in PolyHash:</p>
<pre><code class="language-rust">(hs, ht) = (hasher.hash(s), hasher.hash(t));
hst = (hs * hasher.powr[s.len()] % p + ht) % p;</code></pre>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p>Rev: https://atcoder.jp/contests/abc284/submissions/50879999
Palindrome: https://leetcode.com/submissions/detail/850611043/
Concatenate: https://atcoder.jp/contests/abc312/submissions/44107852</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="polyhash2"><a class="header" href="#polyhash2">PolyHash2</a></h1>
<p>Double PolyHash.</p>
<pre><code class="language-rust">fn powmod(a: u64, mut b: u64, m: u64) -&gt; u64 {
    let mut base = a % m;
    let mut res = 1;
    while b != 0 {
        if b &amp; 1 == 1 {
            res = res * base % m;
        }
        base = base * base % m;
        b &gt;&gt;= 1;
    }
    res
}

struct PolyHasher2 {
    prime: (u64, u64),
    powr: Vec&lt;(u64, u64)&gt;,
    pinv: Vec&lt;(u64, u64)&gt;,
}

impl PolyHasher2 {
    fn new(n: usize) -&gt; Self {
        let base = (31, 37);
        let prime = (1_000_000_007, 1_000_000_009);
        let mut powr = vec![(1, 1); n];
        let mut pinv = vec![(1, 1); n];
        for i in 1..n {
            powr[i].0 = powr[i - 1].0 * base.0 % prime.0;
            powr[i].1 = powr[i - 1].1 * base.1 % prime.1;
        }
        pinv[n - 1].0 = powmod(powr[n - 1].0, prime.0 - 2, prime.0);
        pinv[n - 1].1 = powmod(powr[n - 1].1, prime.1 - 2, prime.1);
        for i in (0..(n - 1)).rev() {
            pinv[i].0 = pinv[i + 1].0 * base.0 % prime.0;
            pinv[i].1 = pinv[i + 1].1 * base.1 % prime.1;
        }
        Self { prime, powr, pinv }
    }

    fn hash(&amp;self, arr: &amp;[u64]) -&gt; Vec&lt;(u64, u64)&gt; {
        assert!(arr.iter().all(|&amp;x| x != 0));
        let mut h = vec![(0, 0); arr.len()];
        h[0].0 = arr[0] % self.prime.0;
        h[0].1 = arr[0] % self.prime.1;
        for i in 1..arr.len() {
            h[i].0 = (h[i - 1].0 + arr[i] * self.powr[i].0 % self.prime.0) % self.prime.0;
            h[i].1 = (h[i - 1].1 + arr[i] * self.powr[i].1 % self.prime.1) % self.prime.1;
        }
        h
    }

    // l..r
    // rev(S[l..r]) = revS[(n - r)..(n - l)]
    fn range(&amp;self, h: &amp;[(u64, u64)], l: usize, r: usize) -&gt; (u64, u64) {
        assert!(l &lt; h.len());
        assert!(r &lt;= h.len());
        if l == r {
            (0, 0)
        } else if l == 0 {
            h[r - 1]
        } else {
            let h0 = (self.prime.0 + h[r - 1].0 - h[l - 1].0) % self.prime.0 * self.pinv[l].0;
            let h1 = (self.prime.1 + h[r - 1].1 - h[l - 1].1) % self.prime.1 * self.pinv[l].1;
            (h0 % self.prime.0, h1 % self.prime.1)
        }
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc284/submissions/50879393">https://atcoder.jp/contests/abc284/submissions/50879393</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dijkstra"><a class="header" href="#dijkstra">Dijkstra</a></h1>
<pre><code class="language-rust">use std::cmp::Reverse;

fn dijkstra&lt;T&gt;(adj: &amp;Vec&lt;Vec&lt;(usize, T)&gt;&gt;, s: usize, inf: T) -&gt; (Vec&lt;T&gt;, Vec&lt;usize&gt;)
where
    T: std::ops::Add&lt;Output = T&gt; + Ord + Copy + Default,
{
    let n = adj.len();
    let mut que = std::collections::BinaryHeap::new(); // max heap
    let mut dis = vec![inf; n];
    let mut par = vec![!0; n];

    dis[s] = T::default();
    par[s] = s;
    que.push((Reverse(dis[s]), s));

    while let Some((Reverse(d), u)) = que.pop() {
        if d &gt; dis[u] {
            continue;
        }
        for &amp;(v, w) in adj[u].iter() {
            let new_d = dis[u] + w;
            if new_d &lt; dis[v] {
                dis[v] = new_d;
                par[v] = u;
                que.push((Reverse(dis[v]), v));
            }
        }
    }

    (dis, par)
}</code></pre>
<p><a href="https://cses.fi/problemset/result/7462588/">https://cses.fi/problemset/result/7462588/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spfa"><a class="header" href="#spfa">SPFA</a></h1>
<pre><code class="language-rust">#[derive(Debug)]
struct SPFA&lt;T&gt; {
    dis: Vec&lt;T&gt;,
    par: Vec&lt;usize&gt;,
    cnt: Vec&lt;usize&gt;,
}

impl&lt;T: Copy + Ord + Default + std::ops::Add&lt;Output = T&gt;&gt; SPFA&lt;T&gt; {
    fn new(n: usize, inf: T) -&gt; Self {
        Self {
            dis: vec![inf; n],
            par: vec![!0; n],
            cnt: vec![0; n],
        }
    }

    fn spfa(&amp;mut self, adj: &amp;Vec&lt;Vec&lt;(usize, T)&gt;&gt;, sources: &amp;Vec&lt;usize&gt;) {
        let n = adj.len();
        let mut que = std::collections::VecDeque::new();
        let mut inq = vec![false; n];

        for &amp;s in sources.iter() {
            self.dis[s] = T::default();
            self.par[s] = s;
            que.push_back(s);
            inq[s] = true;
        }

        while let Some(u) = que.pop_front() {
            inq[u] = false;
            for &amp;(v, w) in adj[u].iter() {
                let new_d = self.dis[u] + w;
                if new_d &lt; self.dis[v] {
                    self.dis[v] = new_d;
                    self.par[v] = u;
                    self.cnt[v] += 1;
                    if !inq[v] &amp;&amp; self.cnt[v] &lt; n {
                        que.push_back(v);
                        inq[v] = true;
                    }
                }
            }
        }
    }
}</code></pre>
<p><a href="https://cses.fi/problemset/result/5980703/">https://cses.fi/problemset/result/5980703/</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topological-sort"><a class="header" href="#topological-sort">Topological Sort</a></h1>
<p>Kahn's Algorithm</p>
<pre><code class="language-rust">fn topological_sort(adj: &amp;Vec&lt;Vec&lt;usize&gt;&gt;) -&gt; Vec&lt;usize&gt; {
    let n = adj.len();
    let mut indeg = vec![0; n];
    for u in 0..n {
        for &amp;v in adj[u].iter() {
            indeg[v] += 1;
        }
    }

    let mut que = std::collections::VecDeque::new();
    for u in 0..n {
        if indeg[u] == 0 {
            que.push_back(u);
        }
    }

    let mut nodes = vec![];
    while let Some(u) = que.pop_front() {
        nodes.push(u);
        for &amp;v in adj[u].iter() {
            indeg[v] -= 1;
            if indeg[v] == 0 {
                que.push_back(v);
            }
        }
    }

    nodes
}</code></pre>
<p><a href="https://atcoder.jp/contests/dp/submissions/41166690">https://atcoder.jp/contests/dp/submissions/41166690</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tarjan-scc"><a class="header" href="#tarjan-scc">Tarjan SCC</a></h1>
<pre><code class="language-rust">struct TarjanSCC {
    order: usize,
    index: Vec&lt;usize&gt;,
    lowlink: Vec&lt;usize&gt;,
    onstack: Vec&lt;bool&gt;,
    stack: Vec&lt;usize&gt;,
    scc_id: usize,
    belong: Vec&lt;usize&gt;,
}

// https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
// Returns:
//    num_scc: number of scc
//    belong: which scc each vertex belongs to
// The order of scc is a *reversed* topological sort of the DAG.
fn tarjan_scc(adj: &amp;Vec&lt;Vec&lt;usize&gt;&gt;) -&gt; (usize, Vec&lt;usize&gt;) {
    let n = adj.len();
    let mut data = TarjanSCC {
        order: 0,
        index: vec![!0; n],
        lowlink: vec![0; n],
        onstack: vec![false; n],
        stack: vec![],
        scc_id: 0,
        belong: vec![!0; n],
    };
    for root in 0..data.index.len() {
        if data.index[root] == !0 {
            tarjan_dfs(root, &amp;mut data, adj);
        }
    }
    (data.scc_id, data.belong)
}

fn tarjan_dfs(u: usize, data: &amp;mut TarjanSCC, adj: &amp;Vec&lt;Vec&lt;usize&gt;&gt;) {
    data.index[u] = data.order;
    data.lowlink[u] = data.order;
    data.order += 1;
    data.stack.push(u);
    data.onstack[u] = true;

    for &amp;v in adj[u].iter() {
        if data.index[v] == !0 {
            tarjan_dfs(v, data, adj);
            data.lowlink[u] = data.lowlink[u].min(data.lowlink[v]);
        } else if data.onstack[v] {
            data.lowlink[u] = data.lowlink[u].min(data.index[v]);
        }
    }

    if data.lowlink[u] == data.index[u] {
        while let Some(x) = data.stack.pop() {
            data.onstack[x] = false;
            data.belong[x] = data.scc_id;
            if x == u {
                break;
            }
        }
        data.scc_id += 1;
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/practice2/submissions/53308987">https://atcoder.jp/contests/practice2/submissions/53308987</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sat"><a class="header" href="#2-sat">2-SAT</a></h1>
<pre><code>(p or q) =&gt; add edge (~p =&gt; q), (~q =&gt; p)

(p) = (p or p)
(p xor q) = (~p or ~q) and (p or q)
At least 1 of (p, q) is true: (p or q)
At least 2 of (p, q) is true: (p and q)
At least 1 of (p, q, r) is true: (p or q or r) =&gt; Not a CNF.
At least 2 of (p, q, r) is true: (p or q) and (q or r) and (p or r)
At least 3 of (p, q, r) is true: (p and q and r)

After tarjan scc,
    * No solution if any p has belong[p] = belong[~p].
    * p is true if belong[p] &lt; belong[~p], i.e., topo(p) &gt; topo(~p).

If we get a truth table, we can construct the CNF.
p q   eval
- -    F
- +    T
+ -    F
+ +    T
We ban all the entries that are F. The DNF of banned entries is
    (~p and ~q) or (p and ~q)
Negate the DNF and we get CNF of the T entries:
    (p or q) and (~p or q)
</code></pre>
<pre><code class="language-rust">let mut add_clause = |p: usize, q: usize| {
    adj[p ^ 1].push(q);
    adj[q ^ 1].push(p);
};

// Check contraction
let ok = (0..n).all(|i| belong[2 * i] != belong[2 * i ^ 1]);

// Solution
for i in 0..n {
    let pos_i = 2 * i;
    if belong[pos_i] &lt; belong[pos_i ^ 1] {
        // i is positive
    } else {
        // i is negative
    }
}</code></pre>
<ul>
<li><a href="https://atcoder.jp/contests/practice2/submissions/53310836">https://atcoder.jp/contests/practice2/submissions/53310836</a></li>
<li><a href="https://codeforces.com/contest/1971/submission/260608172">https://codeforces.com/contest/1971/submission/260608172</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diameter-radius-eccentricity"><a class="header" href="#diameter-radius-eccentricity">Diameter, Radius, Eccentricity</a></h1>
<p>Eccentricity(u)
= the longest distance from u in the tree
= the larger of $d(u, s), d(u, t)$ where $s$ to $t$ is a diameter.</p>
<p>$$
\begin{align}
&amp;ecc(u) \
&amp;= \max_{v \in V} d(u, v) \
&amp;= max(d(u, s), d(u, t))
\end{align}
$$</p>
<p>Diameter is the maximum eccentricity, that is, the longest distance in the tree.</p>
<p>$$
d = \max_{u \in V} ecc(u) = \max_{u \in V} \max_{v \in V} d(u, v)
$$</p>
<p>Radius is the minimum eccentricity in the tree.</p>
<p>$$
r = \min_{u \in V} ecc(u) = \min_{u \in V} \max_{v \in V} d(u, v)
$$</p>
<p>The center(s) is the vertices $u$ that has $ecc(u) = r$.</p>
<p>To find $s, t$, we can perform 2 BFS:</p>
<pre><code class="language-rust">let (nodes, _, _) = bfs(&amp;adj, 0);
let s = nodes[nodes.len() - 1];
let (nodes, _, dep_from_s) = bfs(&amp;adj, s);
let t = nodes[nodes.len() - 1];
let (nodes, _, dep_from_t) = bfs(&amp;adj, t);
let ecc = |u: usize| dep_from_s[u].max(dep_from_t[u]);
let diameter = (0..n).map(|u| ecc(u)).max().unwrap(); // or dep1[t]
let radius = (0..n).map(|u| ecc(u)).min().unwrap();</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lca"><a class="header" href="#lca">LCA</a></h1>
<pre><code class="language-rust">struct LCA {
    root: usize,
    dep: Vec&lt;usize&gt;,
    dp: Vec&lt;Vec&lt;usize&gt;&gt;,
}

impl LCA {
    fn from_adj(adj: &amp;Vec&lt;Vec&lt;usize&gt;&gt;) -&gt; Self {
        let n = adj.len();
        let inf = usize::MAX;
        let mut que = std::collections::VecDeque::new();
        let mut dep = vec![inf; n];
        let mut par = (0..n).collect::&lt;Vec&lt;usize&gt;&gt;();
        let root = 0;
        que.push_back(root);
        dep[root] = 0;
        par[root] = root;
        while let Some(u) = que.pop_front() {
            for &amp;v in adj[u].iter() {
                if dep[v] == inf {
                    dep[v] = dep[u] + 1;
                    par[v] = u;
                    que.push_back(v);
                }
            }
        }
        assert!(dep.iter().all(|d| *d != inf));

        let nn = n.next_power_of_two().trailing_zeros() as usize;
        let mut dp = vec![vec![root; n]; nn]; // beyond root is root
        dp[0].clone_from_slice(&amp;par);
        for i in 1..nn {
            for u in 0..n {
                dp[i][u] = dp[i - 1][dp[i - 1][u]];
            }
        }
        Self { root, dep, dp }
    }

    fn kth_par(&amp;self, mut u: usize, k: usize) -&gt; usize {
        for i in 0..self.dp.len() {
            if (k &gt;&gt; i) &amp; 1 == 1 {
                u = self.dp[i][u];
            }
        }
        u
    }

    fn lca(&amp;self, mut u: usize, mut v: usize) -&gt; usize {
        // Make u lower than v
        if self.dep[u] &lt; self.dep[v] {
            (u, v) = (v, u);
        }
        // Make u, v same depth
        u = self.kth_par(u, self.dep[u] - self.dep[v]);
        if u == v {
            return u;
        }
        // Increment binary search to find
        // the topmost node that is not common ancestor
        for i in (0..self.dp.len()).rev() {
            if self.dp[i][u] != self.dp[i][v] {
                u = self.dp[i][u];
                v = self.dp[i][v];
            }
        }
        self.dp[0][u]
    }

    fn dist(&amp;self, u: usize, v: usize) -&gt; usize {
        let lca = self.lca(u, v);
        self.dep[u] + self.dep[v] - 2 * self.dep[lca]
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc209/submissions/49833365">https://atcoder.jp/contests/abc209/submissions/49833365</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ternary-search"><a class="header" href="#ternary-search">Ternary Search</a></h1>
<pre><code class="language-rust">fn ternary_search() { // minimize
    let mut lb = 0.0 as f64;
    let mut ub = (10.0 as f64).powf(19.0);
    let f = |n: f64| -&gt; f64 { 2 * n + 10 * ((1.0 + n).powf(-0.5)) };
    for _ in 0..200 {
        let l = (lb + lb + ub) / 3.0;
        let r = (lb + ub + ub) / 3.0;
        if f(l) &lt;= f(r) {
            ub = r;
        } else {
            lb = l;
        }
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="combtool"><a class="header" href="#combtool">CombTool</a></h2>
<p>$$
x!^{-1}
\equiv (\frac{(x + 1)!}{x + 1}) ^ {-1}
\equiv (x + 1)!^{-1} (x + 1)
\pmod {p}
$$</p>
<pre><code class="language-rust">struct CombTool {
    fact: Vec&lt;Mint&gt;,
    finv: Vec&lt;Mint&gt;,
}

impl CombTool {
    fn new(n: usize) -&gt; CombTool {
        let mut fact = vec![Mint(1); n + 1];
        let mut finv = vec![Mint(1); n + 1];
        for i in 1..=n {
            fact[i] = fact[i - 1] * Mint(i as u64);
        }
        finv[n] = fact[n].inv();
        for i in (1..n).rev() {
            finv[i] = finv[i + 1] * Mint((i + 1) as u64);
        }
        CombTool { fact, finv }
    }
    fn comb(&amp;self, a: usize, b: usize) -&gt; Mint {
        self.fact[a] * self.finv[b] * self.finv[a - b]
    }
    fn perm(&amp;self, a: usize, b: usize) -&gt; Mint {
        self.fact[a] * self.finv[a - b]
    }
    fn hcomb(self, a: usize, b: usize) -&gt; Mint {
        self.comb(a + b - 1, b)
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc262/submissions/37074323">https://atcoder.jp/contests/abc262/submissions/37074323</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-congruence--chinese-remainder-theorem"><a class="header" href="#linear-congruence--chinese-remainder-theorem">Linear Congruence &amp; Chinese Remainder Theorem</a></h1>
<pre><code class="language-rust">fn gcd(a: i64, b: i64) -&gt; i64 {
    if b == 0 {
        a
    } else {
        gcd(b, a.rem_euclid(b))
    }
}

fn extgcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    if b == 0 {
        (1, 0, a) // (x0, y0, g)
    } else {
        let (x1, y1, g) = extgcd(b, a.rem_euclid(b));
        (y1, x1 - y1 * (a / b), g) // (x0, y0, g)
    }
}

fn minv(a: i64, m: i64) -&gt; i64 {
    let (x0, _, _) = extgcd(a, m);
    x0.rem_euclid(m)
}

// ax = b (mod m) has solution
//  x = (a/g)^(-1) * (b/g) (mod m/g)
fn linear_congruence(a: i64, b: i64, m: i64) -&gt; Option&lt;i64&gt; {
    let (inv, _, g) = extgcd(a, m);
    if b % g != 0 {
        None
    } else {
        Some((inv * (b / g)).rem_euclid(m / g))
    }
}

// x = r1 (mod m1)
// x = r2 (mod m2) has solution
// x = m1 q1 + r1 (mod lcm(m1, m2)) where
// q1 = linear_congruence(m1, r2 - r1, m2)
fn crt(coef: &amp;Vec&lt;(i64, i64)&gt;) -&gt; Option&lt;(i64, i64)&gt; {
    let mut m1 = coef[0].0;
    let mut r1 = coef[0].1;
    for i in 1..coef.len() {
        let (m2, r2) = coef[i];
        if let Some((q1, g)) = linear_congruence(m1, r2 - r1, m2) {
            let lcm = m1 / g * m2;
            r1 = (m1 * q1 + r1).rem_euclid(lcm);
            m1 = lcm;
        } else {
            return None;
        }
    }
    Some((m1, r1))
}</code></pre>
<ul>
<li><a href="https://atcoder.jp/contests/abc186/submissions/43184083">https://atcoder.jp/contests/abc186/submissions/43184083</a></li>
<li><a href="https://atcoder.jp/contests/abc193/submissions/43191810">https://atcoder.jp/contests/abc193/submissions/43191810</a></li>
</ul>
<h2 id="linear-congruence"><a class="header" href="#linear-congruence">Linear Congruence</a></h2>
<p>給定 $ax \equiv b \pmod m$ 的 $a, b, m$，求解 $x$。</p>
<p><strong>如果 $b$ 不是 $g = gcd(a, m)$ 的倍數，則無解。</strong></p>
<p>我們證他的反向，即有解時，$b$ 一定是 $g$ 的倍數。
有解代表存在 $x_0$ 使得 $a x_0 \equiv b \pmod m$，即存在整數 $y$ 滿足 $a x_0 + my = b$。
因為 $a$ 與 $m$ 都是 $g$ 的倍數，所以 $b$ 一定是 $g$ 的倍數。</p>
<p><strong>如果 $b$ 是 $g = gcd(a, m)$ 的倍數，則解為 $x \equiv \left(\frac{a}{g}\right)^{-1} \frac{b}{g} \pmod{\frac{m}{g}}$</strong></p>
<p>因為 $ax \equiv b \pmod m$ 中，$a, m$ 可能不互質，所以 $a$ 在 $m$ 下的反元素不一定存在，我們將等式兩側除上 $g$ 使得 $a/g$ 與 $m/g$ 互質：</p>
<p>$$
\begin{align}
a &amp;x \equiv b \pmod m \\
a &amp;x + my = b \\
\frac{a}{g} &amp;x + \frac{m}{g} y = \frac{b}{g} \\
\frac{a}{g} &amp;x \equiv \frac{b}{g} \pmod {\frac{m}{g}} \\
&amp;x \equiv \left(\frac{a}{g}\right)^{-1} \frac{b}{g} \pmod{\frac{m}{g}}
\end{align}
$$</p>
<pre><code class="language-rust">fn linear_congruence(a: i64, b: i64, m: i64) -&gt; Option&lt;i64&gt; {
    let g = gcd(a, m);
    if b.rem_euclid(g) != 0 {
        None
    } else {
        Some((minv(a / g, m / g) * (b / g)).rem_euclid(m / g))
    }
}</code></pre>
<h2 id="extgcd"><a class="header" href="#extgcd">Extgcd</a></h2>
<p>給定 $ax + by = gcd(a, b)$ 中的 $(a, b)$，extgcd 求出一組解 $(x, y)$，其中 $a, b, x, y$ 都可能是負數。</p>
<p>根據 <a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">Bézout's identity</a>，兩數的 gcd 可以寫成兩數的線性組合。於是 Euclidean algorithm 可以寫成：</p>
<p>$$
\begin{align}
g &amp;= a \cdot x_0 + b \cdot y_0  \tag{1} \\
g &amp;= b \cdot x_1 + (a \bmod b) \cdot y_1  \tag{2} \\
&amp;\dots \\
g &amp;= g \cdot 1 + 0 \cdot 0  \tag{3}
\end{align}
$$</p>
<p>因為式 $(3)$ 中的 $(x, y)$ 是已知的，我們想從式 $(3)$ 倒著推，推出式 $(1)$。假設式 $(2)$ 是已知的，我們可以將之寫成式 $(1)$ 的型式：</p>
<p>$$
\begin{align}
g &amp;= b \cdot x_1 + (a \bmod b) \cdot y_1 \\
g &amp;= b \cdot x_1 + (a - \lfloor\frac{a}{b}\rfloor \cdot b) \cdot y_1 \\
g &amp;= a y_1 + b \cdot \left( x_1 - y_1 \cdot \lfloor\frac{a}{b}\rfloor \right)
\end{align}
$$</p>
<p>即</p>
<p>$$
\begin{align}
x_0 &amp;= y_1 \\
y_0 &amp;= x_1 - y_1 \cdot \lfloor\frac{a}{b}\rfloor
\end{align}
$$</p>
<p>於是 code 可以寫成：</p>
<pre><code class="language-rust">fn extgcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    if b == 0 {
        (1, 0, a) // (x0, y0, g)
    } else {
        let (x1, y1, g) = extgcd(b, a.rem_euclid(b));
        (y1, x1 - y1 * (a / b), g) // (x0, y0, g)
    }
}</code></pre>
<h2 id="mod-inverse"><a class="header" href="#mod-inverse">Mod Inverse</a></h2>
<p>如果 $a, m$ 互質，則 <code>extgcd(a, m)</code> 可以求出 $a$ 在 $\pmod m$ 下的反元素，因為 extgcd 可以求出</p>
<p>$$
\begin{align}
ax + my &amp;= gcd(a, m) = 1 \\
ax &amp;= -my + 1 \\
ax &amp;\equiv 1 \pmod m
\end{align}
$$</p>
<p>的一組解 $(x_0, y_0)$，我們再將 $x_0$ 移至 $\mod m$ 底下即可。</p>
<p>如果 $a, m$ 不互質，則 <code>extgcd(a, m)</code> 求出來的是 $\frac a g$ 在 $\pmod {\frac{m}{g}}$ 下的反元素。</p>
<h2 id="reference-1"><a class="header" href="#reference-1">Reference</a></h2>
<ul>
<li><a href="http://www.mathsgreat.com/article/article_031.pdf">http://www.mathsgreat.com/article/article_031.pdf</a></li>
<li><a href="https://cp-algorithms.com/algebra/linear-diophantine-equation.html">https://cp-algorithms.com/algebra/linear-diophantine-equation.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linear-congruence--chinese-remainder-theorem-1"><a class="header" href="#linear-congruence--chinese-remainder-theorem-1">Linear Congruence &amp; Chinese Remainder Theorem</a></h1>
<pre><code class="language-rust">fn gcd(a: i64, b: i64) -&gt; i64 {
    if b == 0 {
        a
    } else {
        gcd(b, a.rem_euclid(b))
    }
}

fn extgcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    if b == 0 {
        (1, 0, a) // (x0, y0, g)
    } else {
        let (x1, y1, g) = extgcd(b, a.rem_euclid(b));
        (y1, x1 - y1 * (a / b), g) // (x0, y0, g)
    }
}

fn minv(a: i64, m: i64) -&gt; i64 {
    let (x0, _, _) = extgcd(a, m);
    x0.rem_euclid(m)
}

// ax = b (mod m) has solution
//  x = (a/g)^(-1) * (b/g) (mod m/g)
fn linear_congruence(a: i64, b: i64, m: i64) -&gt; Option&lt;i64&gt; {
    let (inv, _, g) = extgcd(a, m);
    if b % g != 0 {
        None
    } else {
        Some((inv * (b / g)).rem_euclid(m / g))
    }
}

// x = r1 (mod m1)
// x = r2 (mod m2) has solution
// x = m1 q1 + r1 (mod lcm(m1, m2)) where
// q1 = linear_congruence(m1, r2 - r1, m2)
fn crt(coef: &amp;Vec&lt;(i64, i64)&gt;) -&gt; Option&lt;(i64, i64)&gt; {
    let mut m1 = coef[0].0;
    let mut r1 = coef[0].1;
    for i in 1..coef.len() {
        let (m2, r2) = coef[i];
        if let Some((q1, g)) = linear_congruence(m1, r2 - r1, m2) {
            let lcm = m1 / g * m2;
            r1 = (m1 * q1 + r1).rem_euclid(lcm);
            m1 = lcm;
        } else {
            return None;
        }
    }
    Some((m1, r1))
}</code></pre>
<ul>
<li><a href="https://atcoder.jp/contests/abc186/submissions/43184083">https://atcoder.jp/contests/abc186/submissions/43184083</a></li>
<li><a href="https://atcoder.jp/contests/abc193/submissions/43191810">https://atcoder.jp/contests/abc193/submissions/43191810</a></li>
</ul>
<h2 id="linear-congruence-1"><a class="header" href="#linear-congruence-1">Linear Congruence</a></h2>
<p>給定 $ax \equiv b \pmod m$ 的 $a, b, m$，求解 $x$。</p>
<p><strong>如果 $b$ 不是 $g = gcd(a, m)$ 的倍數，則無解。</strong></p>
<p>我們證他的反向，即有解時，$b$ 一定是 $g$ 的倍數。
有解代表存在 $x_0$ 使得 $a x_0 \equiv b \pmod m$，即存在整數 $y$ 滿足 $a x_0 + my = b$。
因為 $a$ 與 $m$ 都是 $g$ 的倍數，所以 $b$ 一定是 $g$ 的倍數。</p>
<p><strong>如果 $b$ 是 $g = gcd(a, m)$ 的倍數，則解為 $x \equiv \left(\frac{a}{g}\right)^{-1} \frac{b}{g} \pmod{\frac{m}{g}}$</strong></p>
<p>因為 $ax \equiv b \pmod m$ 中，$a, m$ 可能不互質，所以 $a$ 在 $m$ 下的反元素不一定存在，我們將等式兩側除上 $g$ 使得 $a/g$ 與 $m/g$ 互質：</p>
<p>$$
\begin{align}
a &amp;x \equiv b \pmod m \\
a &amp;x + my = b \\
\frac{a}{g} &amp;x + \frac{m}{g} y = \frac{b}{g} \\
\frac{a}{g} &amp;x \equiv \frac{b}{g} \pmod {\frac{m}{g}} \\
&amp;x \equiv \left(\frac{a}{g}\right)^{-1} \frac{b}{g} \pmod{\frac{m}{g}}
\end{align}
$$</p>
<pre><code class="language-rust">fn linear_congruence(a: i64, b: i64, m: i64) -&gt; Option&lt;i64&gt; {
    let g = gcd(a, m);
    if b.rem_euclid(g) != 0 {
        None
    } else {
        Some((minv(a / g, m / g) * (b / g)).rem_euclid(m / g))
    }
}</code></pre>
<h2 id="extgcd-1"><a class="header" href="#extgcd-1">Extgcd</a></h2>
<p>給定 $ax + by = gcd(a, b)$ 中的 $(a, b)$，extgcd 求出一組解 $(x, y)$，其中 $a, b, x, y$ 都可能是負數。</p>
<p>根據 <a href="https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity">Bézout's identity</a>，兩數的 gcd 可以寫成兩數的線性組合。於是 Euclidean algorithm 可以寫成：</p>
<p>$$
\begin{align}
g &amp;= a \cdot x_0 + b \cdot y_0  \tag{1} \\
g &amp;= b \cdot x_1 + (a \bmod b) \cdot y_1  \tag{2} \\
&amp;\dots \\
g &amp;= g \cdot 1 + 0 \cdot 0  \tag{3}
\end{align}
$$</p>
<p>因為式 $(3)$ 中的 $(x, y)$ 是已知的，我們想從式 $(3)$ 倒著推，推出式 $(1)$。假設式 $(2)$ 是已知的，我們可以將之寫成式 $(1)$ 的型式：</p>
<p>$$
\begin{align}
g &amp;= b \cdot x_1 + (a \bmod b) \cdot y_1 \\
g &amp;= b \cdot x_1 + (a - \lfloor\frac{a}{b}\rfloor \cdot b) \cdot y_1 \\
g &amp;= a y_1 + b \cdot \left( x_1 - y_1 \cdot \lfloor\frac{a}{b}\rfloor \right)
\end{align}
$$</p>
<p>即</p>
<p>$$
\begin{align}
x_0 &amp;= y_1 \\
y_0 &amp;= x_1 - y_1 \cdot \lfloor\frac{a}{b}\rfloor
\end{align}
$$</p>
<p>於是 code 可以寫成：</p>
<pre><code class="language-rust">fn extgcd(a: i64, b: i64) -&gt; (i64, i64, i64) {
    if b == 0 {
        (1, 0, a) // (x0, y0, g)
    } else {
        let (x1, y1, g) = extgcd(b, a.rem_euclid(b));
        (y1, x1 - y1 * (a / b), g) // (x0, y0, g)
    }
}</code></pre>
<h2 id="mod-inverse-1"><a class="header" href="#mod-inverse-1">Mod Inverse</a></h2>
<p>如果 $a, m$ 互質，則 <code>extgcd(a, m)</code> 可以求出 $a$ 在 $\pmod m$ 下的反元素，因為 extgcd 可以求出</p>
<p>$$
\begin{align}
ax + my &amp;= gcd(a, m) = 1 \\
ax &amp;= -my + 1 \\
ax &amp;\equiv 1 \pmod m
\end{align}
$$</p>
<p>的一組解 $(x_0, y_0)$，我們再將 $x_0$ 移至 $\mod m$ 底下即可。</p>
<p>如果 $a, m$ 不互質，則 <code>extgcd(a, m)</code> 求出來的是 $\frac a g$ 在 $\pmod {\frac{m}{g}}$ 下的反元素。</p>
<h2 id="reference-2"><a class="header" href="#reference-2">Reference</a></h2>
<ul>
<li><a href="http://www.mathsgreat.com/article/article_031.pdf">http://www.mathsgreat.com/article/article_031.pdf</a></li>
<li><a href="https://cp-algorithms.com/algebra/linear-diophantine-equation.html">https://cp-algorithms.com/algebra/linear-diophantine-equation.html</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="techniques"><a class="header" href="#techniques">Techniques</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ceilfloor-division"><a class="header" href="#ceilfloor-division">Ceil/Floor Division</a></h1>
<pre><code class="language-rust">// a/b rounds toward zero, therefore
// when a &gt; 0, we right shift a,
// when a &lt; 0, a/b is what we want
fn ceil_div(mut a: i64, mut b: i64) -&gt; i64 {
    assert!(b != 0);
    a *= b.signum();
    b = b.abs();
    if a &gt;= 0 {
        (a + b - 1) / b
    } else {
        a / b
    }
}

// a/b rounds toward zero, therefore
// when a &gt; 0, a/b is what we want
// when a &lt; 0, we left shift a.
fn floor_div(mut a: i64, mut b: i64) -&gt; i64 {
    assert!(b != 0);
    a *= b.signum();
    b = b.abs();
    if a &gt;= 0 {
        a / b
    } else {
        (a - (b - 1)) / b
    }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc334/submissions/48817234">https://atcoder.jp/contests/abc334/submissions/48817234</a></p>
<p>另解，利用 <code>a.div_euclid(b)</code>：</p>
<pre><code class="language-rust">// a.div_euclid(b) is the same as floor(a/b)
fn floor_div(a: i64, b: i64) -&gt; i64 {
    a.div_euclid(b)
}

// Add 1 to floor(a/b) if needed to get ceil(a/b)
fn ceil_div(a: i64, b: i64) -&gt; i64 {
    a.div_euclid(b) + if a.rem_euclid(b) != 0 { 1 } else { 0 }
}</code></pre>
<p><a href="https://atcoder.jp/contests/abc334/submissions/48817195">https://atcoder.jp/contests/abc334/submissions/48817195</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="square-number"><a class="header" href="#square-number">Square Number</a></h1>
<p>Let <code>f(x)</code> = largest divisor of x that is square number.
<code>a * b</code> is square number if and only if <code>a / f(a) == b / f(b)</code>.</p>
<pre><code class="language-rust">// Build f
let mut f = vec![0; m + 1];
for d in (1..).take_while(|&amp;d| d * d &lt;= m) {
    for x in ((d * d)..=m).step_by(d * d) {
        f[x] = d * d;
    }
}</code></pre>
<p>ABC254D, ABC342D: <a href="https://atcoder.jp/contests/abc342/submissions/50600083">https://atcoder.jp/contests/abc342/submissions/50600083</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiples-in-range"><a class="header" href="#multiples-in-range">Multiples in Range</a></h1>
<pre><code class="language-rust">// f(x, l, r)
//  = number of multiple of x in range [l, r]
//  = max(0, floor(r / x) - ceil(l / x) + 1)
let f = |x: i64, l: i64, r: i64| -&gt; i64 { 
    (r / x - (l + x - 1) / x + 1).max(0) 
};</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-sets"><a class="header" href="#2-sets">2 Sets</a></h1>
<p>Dynamic K Largest Items using 2 Sets.</p>
<pre><code class="language-rust">let mut cnt = 0;
let mut larger = std::collection::BTreeeSet::new();
let mut smaller = std::collection::BTreeeSet::new();

for i, new_x in arr.iter().enumerate() {
    smaller.insert(new_x, i);

    // Balance the size, expect larger.len() to be k
    while larger.len() &lt; k &amp;&amp; smaller.len() &gt; 0 {
        let (x, id) = smaller.pop_last(); // largest in smaller
        larger.insert((x, id));
        cnt += x;
    }
    while larger.len() &gt; k &amp;&amp; larger.len() &gt; 0 {
        let (x, id) = larger.pop_first(); // smallest in largest
        smaller.insert((x, id));
        cnt -= x;
    }

    // Ensure the order by exchanging
    // smallest(larger) should &gt;= largest(smaller)
    while larger.len() &gt; 0 &amp;&amp; smaller.len() &gt; 0 {
        let (x1, id1) = *larger.iter().next().unwrap(); // smallest
        let (x2, id2) = *smaller.iter().last().unwrap(); // largest
        if x1 &lt; x2 {
            larger.remove(&amp;(x1, id1));
            larger.insert((x2, id2));
            smaller.remove(&amp;(x2, id2));
            smaller.insert((x1, id1));
            cnt += x2;
            cnt -= x1;
        } else {
            break;
        }
    }
}</code></pre>
<ul>
<li><a href="https://atcoder.jp/contests/abc312/submissions/44105261">https://atcoder.jp/contests/abc312/submissions/44105261</a></li>
<li><a href="https://atcoder.jp/contests/abc314/submissions/44556667">https://atcoder.jp/contests/abc314/submissions/44556667</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="longest-common-prefix"><a class="header" href="#longest-common-prefix">Longest Common Prefix</a></h1>
<blockquote>
<p>Given n strings, for each i compute $sum_{j \lt i} LCP(S_i, S_j)$. [ABC353E]</p>
</blockquote>
<p>Store all the prefixes of previous strings and their occurrence as F in prior.
For each i, for all the prefixes of S[i], sum their frequency in F.</p>
<p><a href="https://atcoder.jp/contests/abc353/submissions/53376843">https://atcoder.jp/contests/abc353/submissions/53376843</a></p>
<blockquote>
<p>Given n strings, for each i compute $max_{j \neq i} LCP(S_i, S_j)$. [ABC287E]</p>
</blockquote>
<p>Store all the prefixes of all strings and their occurrence as F in prior.
For each i, inspect all the prefix of S[i] and check in F if the occurrence of the prefix &gt;= 2 (itself and the other). The length of the longest one is the answer.</p>
<p><a href="https://atcoder.jp/contests/abc287/submissions/38442757">https://atcoder.jp/contests/abc287/submissions/38442757</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coordinate-compression"><a class="header" href="#coordinate-compression">Coordinate Compression</a></h1>
<pre><code class="language-rust">fn compress&lt;T: Clone + Ord&gt;(arr: &amp;[T]) -&gt; (Vec&lt;usize&gt;, Vec&lt;T&gt;) {
    let mut s = arr.to_vec();
    s.sort();
    s.dedup();
    let res = arr
        .iter()
        .map(|x| s.binary_search(x).unwrap())
        .collect::&lt;Vec&lt;_&gt;&gt;();
    (res, s)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-graph"><a class="header" href="#functional-graph">Functional Graph</a></h1>
<h2 id="finding-cycle-in-functional-graph"><a class="header" href="#finding-cycle-in-functional-graph">Finding Cycle in Functional Graph</a></h2>
<pre><code class="language-rust">let mut vis = vec![false; n];
vis[0] = true;
let mut u = nxt[0];
while !vis[u] {
    vis[u] = true;
    u = nxt[u];
}

// u is the start of cycle
let mut cycle = vec![u];
let mut v = nxt[u];
while v != u {
    cycle.push(v);
    v = nxt[v];
}
cycle.push(u);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="maximum-match-for-subsequence"><a class="header" href="#maximum-match-for-subsequence">Maximum Match for Subsequence</a></h1>
<pre><code class="language-rust">// Find the maximum length of prefix of t contained as a subsequence of s
fn max_match(s: &amp;Vec&lt;char&gt;, t: &amp;Vec&lt;char&gt;) -&gt; usize {
    let mut t_idx = 0;
    for i in 0..s.len() {
        if t_idx &lt; t.len() &amp;&amp; s[i] == t[t_idx] {
            t_idx += 1;
        }
    }
    t_idx
}</code></pre>
<p>Sequence <code>[*a, *b]</code> contains <code>t</code> as subsequence if and only if <code>max_match(a, t) + max_match(rev(b), rev(t)) &gt;= t.len()</code></p>
<p><a href="https://atcoder.jp/contests/abc324/submissions/46616960">https://atcoder.jp/contests/abc324/submissions/46616960</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="merge-2-sorted-array"><a class="header" href="#merge-2-sorted-array">Merge 2 Sorted Array</a></h1>
<pre><code class="language-rust">fn merge&lt;T: Clone + std::cmp::PartialOrd&gt;(arr1: &amp;Vec&lt;T&gt;, arr2: &amp;Vec&lt;T&gt;) -&gt; Vec&lt;T&gt; {
    let (n, m) = (arr1.len(), arr2.len());
    let mut i = 0;
    let mut j = 0;
    let mut res = vec![];
    while i &lt; n &amp;&amp; j &lt; m {
        if arr1[i] &lt; arr2[j] {
            res.push(arr1[i].clone());
            i += 1;
        } else {
            res.push(arr2[j].clone());
            j += 1;
        }
    }
    res.extend(arr1[i..n].to_vec());
    res.extend(arr2[j..m].to_vec());
    res
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="techniques-1"><a class="header" href="#techniques-1">Techniques</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-basic"><a class="header" href="#rust-basic">Rust Basic</a></h1>
<pre><code class="language-rust">#![allow(unused)]

fn main() {
}

fn read&lt;T: std::str::FromStr&gt;() -&gt; T {
    let mut s = String::new();
    std::io::stdin().read_line(&amp;mut s).ok();
    s.trim().parse().ok().unwrap()
}

fn readv&lt;T: std::str::FromStr&gt;() -&gt; Vec&lt;T&gt; {
    read::&lt;String&gt;()
        .split_ascii_whitespace()
        .map(|t| t.parse().ok().unwrap())
        .collect()
}

fn reads() -&gt; Vec&lt;char&gt; {
    read::&lt;String&gt;().chars().collect()
}

fn mapv&lt;T, S, F: Fn(&amp;T) -&gt; S&gt;(arr: &amp;Vec&lt;T&gt;, f: F) -&gt; Vec&lt;S&gt; {
    arr.iter().map(f).collect()
}

fn join&lt;T: ToString&gt;(arr: &amp;[T], sep: &amp;str) -&gt; String {
    arr.iter()
        .map(|x| x.to_string())
        .collect::&lt;Vec&lt;String&gt;&gt;()
        .join(sep)
}</code></pre>
<h1 id="inspect-4-neighbors"><a class="header" href="#inspect-4-neighbors">Inspect 4 Neighbors</a></h1>
<pre><code class="language-rust">for (dr, dc) in [(1, 0), (!0, 0), (0, 1), (0, !0)] {
    let nr = r.wrapping_add(dr);
    let nc = c.wrapping_add(dc);
    if nr &gt;= n || nc &gt;= m {
        continue;
    }
}</code></pre>
<p>or</p>
<pre><code class="language-rust">for (dr, dc) in [(0, 1), (0, -1), (1, 0), (-1, 0)] {
    let nr = r.checked_add_signed(dr).unwrap_or(n);
    let nc = c.checked_add_signed(dc).unwrap_or(m);
    if nr &gt;= n || nc &gt;= m {
        continue;
    }
}</code></pre>
<h2 id="io-flush"><a class="header" href="#io-flush">IO Flush</a></h2>
<pre><code class="language-rust">use std::io::Write;
std::io::stdout().flush();</code></pre>
<h2 id="string-conversion"><a class="header" href="#string-conversion">String Conversion</a></h2>
<pre><code class="language-rust">// String to int
"100".parse::&lt;i32&gt;().unwrap();
// char to u32
'c'.to_digit(10); // or 'c' as u32
// u32 to char
char::from_u32(97).unwrap(); // 'A'
char::from_digit(8, 10).unwrap();</code></pre>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<pre><code>cargo add proconio
</code></pre>
<pre><code class="language-toml">[package]
name = "ac"
version = "0.1.0"
edition = "2021"
default-run = "main"

[dependencies]
proconio = { version = "0.4.5", features = ["derive"] }

[[bin]]
name = "main"
path = "src/main.rs"

[[bin]]
name = "ans"
path = "src/ans.rs"
</code></pre>
<h2 id="comparing-outputs"><a class="header" href="#comparing-outputs">Comparing Outputs</a></h2>
<pre><code class="language-shell">diff &lt;(cargo run &lt; inp.txt) &lt;(cargo run --bin ans &lt; inp.txt)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cartesian-product"><a class="header" href="#cartesian-product">Cartesian Product</a></h1>
<pre><code class="language-rust">// cartesian(0..h, 0..w)
// cartesian(0..=h, 0..w)
// cartesian(0..h, 0..=w)
// cartesian(0..=h, 0..=w).collect()
fn cartesian&lt;T, R1, R2&gt;(r1: R1, r2: R2) -&gt; impl Iterator&lt;Item = (T, T)&gt;
where
    T: Clone,
    R1: std::ops::RangeBounds&lt;T&gt; + Iterator&lt;Item = T&gt; + Clone,
    R2: std::ops::RangeBounds&lt;T&gt; + Iterator&lt;Item = T&gt; + Clone,
{
    r1.flat_map(move |x| r2.clone().map(move |y| (x.clone(), y)))
}</code></pre>
<p><code>RangeBounds</code> is a trait that <code>Range</code> and <code>RangeInclusive</code> both implements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ordered-float"><a class="header" href="#ordered-float">Ordered Float</a></h1>
<pre><code class="language-rust">use std::cmp::Ordering;

#[derive(PartialEq, PartialOrd, Clone, Copy)]
struct F(f64);

impl Eq for F {}

impl Ord for F {
    fn cmp(&amp;self, other: &amp;F) -&gt; Ordering {
        self.partial_cmp(other).unwrap()
    }
}</code></pre>
<p>or</p>
<pre><code class="language-rust">arr.sort_by_cmp(|a: f64, b: f64| a.partial_cmp(&amp;b));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="default-hasing"><a class="header" href="#default-hasing">Default Hasing</a></h1>
<pre><code class="language-rust">use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};

fn hash&lt;T: Hash&gt;(x: &amp;T) -&gt; u64 {
    let mut h = DefaultHasher::new();
    x.hash(&amp;mut h);
    h.finish()
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
